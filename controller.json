{"slots":{"0":{"name":"core","type":{"events":[],"methods":[]}},"1":{"name":"atmofueltank_1","type":{"events":[],"methods":[]}},"2":{"name":"hover","type":{"events":[],"methods":[]}},"3":{"name":"screen","type":{"events":[],"methods":[]}},"4":{"name":"screen","type":{"events":[],"methods":[]}},"5":{"name":"telemetr","type":{"events":[],"methods":[]}},"6":{"name":"emitter","type":{"events":[],"methods":[]}},"7":{"name":"databank","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"-- category panel display helpers\n_autoconf = {}\n_autoconf.panels = {}\n_autoconf.panels_size = 0\n_autoconf.displayCategoryPanel = function(elements, size, title, type, widgetPerData)\n    widgetPerData = widgetPerData or false -- default to one widget for all data\n    if size > 0 then\n        local panel = system.createWidgetPanel(title)\n        local widget\n        if not widgetPerData then\n            widget = system.createWidget(panel, type)\n        end\n        for i = 1, size do\n            if widgetPerData then\n                widget = system.createWidget(panel, type)\n            end\n            system.addDataToWidget(elements[i].getWidgetDataId(), widget)\n        end\n        _autoconf.panels_size = _autoconf.panels_size + 1\n        _autoconf.panels[_autoconf.panels_size] = panel\n    end\nend\n_autoconf.hideCategoryPanels = function()\n    for i=1,_autoconf.panels_size do\n        system.destroyWidgetPanel(_autoconf.panels[i])\n    end\nend\n-- Proxy array to access auto-plugged slots programmatically\n\natmofueltank = {}\natmofueltank[1] = atmofueltank_1\natmofueltank_size = 0\n\nspacefueltank = {}\nspacefueltank_size = 0\n\nrocketfueltank = {}\nrocketfueltank_size = 0\n\nweapon = {}\nweapon_size = 0\n\nradar = {}\nradar_size = 0\n-- End of auto-generated code\npitchInput = 0\nrollInput = 0\nyawInput = 0\nbrakeInput = 0\n\nNav = Navigator.new(system, core, unit)\nNav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})\nNav.axisCommandManager:setTargetGroundAltitude(0)\n\n-- Parenting widget\n--parentingPanelId = system.createWidgetPanel(\"Docking\")\n--parentingWidgetId = system.createWidget(parentingPanelId,\"parenting\")\n--system.addDataToWidget(unit.getWidgetDataId(),parentingWidgetId)\n\n-- Combat stress widget\n--coreCombatStressPanelId = system.createWidgetPanel(\"Core combat stress\")\n--coreCombatStressgWidgetId = system.createWidget(coreCombatStressPanelId,\"core_stress\")\n--system.addDataToWidget(core.getWidgetDataId(),coreCombatStressgWidgetId)\n\n-- element widgets\n-- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.\n--_autoconf.displayCategoryPanel(weapon, weapon_size, \"Weapons\", \"weapon\", true)\n--core.showWidget()\n--_autoconf.displayCategoryPanel(radar, radar_size, \"Periscope\", \"periscope\")\nplaceRadar = true\nif atmofueltank_size > 0 then\n    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, \"Atmo Fuel\", \"fuel_container\")\n    if placeRadar then\n        _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n        placeRadar = false\n    end\nend\nif spacefueltank_size > 0 then\n    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, \"Space Fuel\", \"fuel_container\")\n    if placeRadar then\n        _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n        placeRadar = false\n    end\nend\n_autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, \"Rocket Fuel\", \"fuel_container\")\nif placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels\n    _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n    placeRadar = false\nend\nif antigrav ~= nil then antigrav.showWidget() end\nif warpdrive ~= nil then warpdrive.showWidget() end\nif gyro ~= nil then gyro.showWidget() end\nif shield ~= nil then shield.showWidget() end\n\n-- freeze the player in he is remote controlling the construct\nif unit.isRemoteControlled() == 1 then\n    player.freeze(0)\nend\n\n-- landing gear\n-- make sure every gears are synchonized with the first\ngearExtended = (unit.isAnyLandingGearDeployed() == 1) -- make sure it's a lua boolean\nif gearExtended then\n    unit.deployLandingGears()\nelse\n    unit.retractLandingGears()\nend\n","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"0"},{"code":"_autoconf.hideCategoryPanels()\nif antigrav ~= nil then antigrav.hideWidget() end\nif warpdrive ~= nil then warpdrive.hideWidget() end\nif gyro ~= nil then gyro.hideWidget() end\ncore.hideWidget()\nunit.switchOffHeadlights()\n","filter":{"args":[],"signature":"onStop()","slotKey":"-1"},"key":"1"},{"code":"system.showScreen(true)\nunit.setTimer(\"t\",0.05)\nverticalStrafeAcceleration = vec3()\nvertAcceleration = {0,0,0}\npercX = 1\npercXInput = 0\ntargetAlt = 0.5\ndistance = 0\ndistWas = 0\ndistChange = 0\nmanualBrake = false\n\ndestTo = vec3()\nlenBSelf = 0\nlenBSelfWas = 0\nlenBSelfChange = 0\nconstructVelocity = vec3()\nconstructForward = vec3()\nconstructRight = vec3()\n\nvelocityForwardDeg = 0\nvelocityRightDeg = 0\naddPitchDeg = 0\naddRollDeg = 0\nvelDotForw = 0\nvelDotRight = 0\nmanualControl = false\nvertDeg = 0\nfolldownRightDeg=0\nvdeg = 0\ngTDeg = 0\ntargetMinDist = 3.5\n\nfunction getVertDeg(worldVertical,constructUp)\n    local vertDeg = math.acos(utils.clamp(constructUp:dot(worldVertical), -1, 1)) * constants.rad2deg\n    return vertDeg\nend\n\n-- devs function from \\Dual Universe\\data\\lua\\Helpers.lua\nfunction getRoll(gravityDirection, forward, right)\n    local horizontalRight = gravityDirection:cross(forward):normalize_inplace()\n    local roll = math.acos(utils.clamp(horizontalRight:dot(right), -1, 1)) * constants.rad2deg\n    if horizontalRight:cross(right):dot(forward) < 0 then roll = -roll end\n    return roll\nend\n\nfunction toStr(a)\n    if a[1] then\n        return string.format(\"(%0.3f,%0.3f,%0.3f)\", a[1] or 0, a[2] or 0, a[3] or 0)\n    end\n    return string.format(\"(%0.3f,%0.3f,%0.3f)\", a.x or 0, a.y or 0, a.z or 0)\nend\n\nfunction seeParams()\n    content = \n    [[<div style=\"position:absolute; left:5vh; top:20vh; display: block; width:90vw; height:90vh; text-align:left; font-size:2vh;\">]]\n    .. \"R \" .. utils.round(currentRollDeg,0.0001) \n    .. \"<br>P \" .. utils.round(currentPitchDeg,0.0001) \n    .. \"<br>Y \" .. utils.round(currentYawDeg,0.0001)\n    .. \"<br>V \" .. utils.round(vertDeg,0.0001)\n    .. \"<br>F \" .. utils.round(folldownRightDeg,0.0001)\n    .. \"<br>vdeg \" .. utils.round(vdeg,0.0001)\n    .. \"<br>gTDeg \" .. utils.round(gTDeg,0.0001)\n    .. \"<br><br>verticalStrafeAcceleration \" .. toStr(verticalStrafeAcceleration)\n    --.. \"<br>CWforward \" .. toStr(vec3(core.getConstructWorldOrientationForward()))\n    --.. \"<br>CWright \" .. toStr(vec3(core.getConstructWorldOrientationRight()))\n    --.. \"<br>up \" .. toStr(vec3(construct.getWorldOrientationUp()))\n    --.. \"<br>OrientationForward \" .. toStr(vec3(construct.getOrientationForward()))\n    --.. \"<br><br>vertAcceleration \" .. toStr(vec3(vertAcceleration))\n    .. \"<br><br>distance \" .. utils.round(distance,0.0001)\n    .. \"<br><br>percXInput \" .. percXInput\n    .. \"<br><br>percX \" .. percX\n    .. \"<br><br>distChange \" .. distChange\n    .. \"<br>targetAlt \" .. targetAlt\n    .. \"<br><br>playerPos \" .. toStr(vec3(player.getWorldPosition()))\n    .. \"<br>lenBSelf \" .. lenBSelf\n    .. \"<br>addPitchDeg \" .. addPitchDeg\n    .. \"<br>lenBSelfChange \" .. lenBSelfChange\n    .. \"<br>constructVelocity \" .. toStr(constructVelocity)\n    .. \"<br>constructVelocityLen \" .. constructVelocity:len()\n    .. \"<br><br>velocityForwardDeg \" .. velocityForwardDeg\n    .. \"<br>addRollDeg \" .. addRollDeg\n    .. \"<br>velDotForwLen \" .. vec3(velDotForw):len()\n    .. \"<br>player.isFrozen() \" .. player.isFrozen()\n    --.. \"<br>horizontalForward \" .. toStr(vec3(core.getWorldVertical()):cross(vec3(core.getConstructWorldOrientationRight())):normalize_inplace())\n    --.. \"<br>target \" .. toStr(vec3(vec3(destTo) - cSelf):normalize_inplace())\n    --.. \"<br><br>pP \" .. utils.round(pseudoPitchDeg,0.0001)\n    --.. \"<br>lenBSelf \" .. utils.round(lenBSelf,0.0001)\n    --.. \"<br>Altitude \" .. utils.round(core.getAltitude(),0.0001)\n    --.. \"<br>AltitudeCh \" .. utils.round(altitudeChange,0.0001)\n    --.. \"<br>needPitch \" .. utils.round(needPitch,0.0001)\n    --.. \"<br>targetAlt \" .. utils.round(targetAlt,0.0001)\n    --.. \"<br>restAltLim \" .. utils.round(restAltLim,0.0001)\n    --.. \"<br>exitCounter \" .. utils.round(exitCounter,0.0001)\n    --.. \"<br><br>speedCompensation \" .. utils.round(speedCompensation,0.0001)\n    --.. \"<br><br>tankA1 \" .. utils.round(atmofueltank_1.getMass(),0.0001)\n    --.. \"<br>tankA2 \" .. utils.round(atmofueltank_2.getMass(),0.0001)\n    --.. \"<br>tankS1 \" .. utils.round(spacefueltank_1.getMass(),0.0001)\n    --.. \"<br><br>pos1 \" .. pos1[\"x\"]\n    --.. \"<br>pos2 \" .. toStr(pos2)\n    --.. \"<br>pos3 \" .. toStr(pos3)\n    --.. \"<br>pos4 \" .. toStr(pos4)\n    .. [[</div>]]\n    system.setScreen(content)\n    if screen then\n        screen.setHTML(content)\n    end\nend\n\n\n\n\n","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"2"},{"code":"seeParams()\npercX = unit.getThrottle()/10000+1\n\nxFactor = 21\ndistance = 0\nif telemetr then\n    distance = telemetr.raycast()[\"distance\"]\nend\nif hover then\n    distance = hover.getDistance()\nend\nif math.abs(targetAlt - distance) > 0.001 then\n    distChange = distWas - distance\n    percXInput = (targetAlt - distance)*0.55 + distChange*3.5\n    distWas = distance\n    percX = 1 + percXInput\n    if targetAlt < 0 and distance < 0.05 then\n        percX = 0\n    end\nend\n\n\nvelDotForw = vec3(constructVelocity:dot(constructForward)):len()\nif math.abs(velocityForwardDeg) > 90 then\n    velDotForw = -velDotForw\nend\n--addPitchDeg = utils.clamp(340*(utils.clamp(lenBSelf - 3.5,0,5)/5) - velDotForw*12.5,-45,185)\n\n\nvelDotRight = vec3(constructVelocity:dot(constructRight)):len()\n--addRollDeg = utils.clamp(30*(utils.clamp(velocityForwardDeg*constructVelocity:len(),-90,90)/90),-35,35)\nif math.abs(velocityRightDeg) > 90 then\n    velDotRight = -velDotRight\nend\n--addRollDeg = utils.clamp(velDotRight*13.5,-40,40)\n\n\nif lenBSelf < 3.7 then\n    if targetAlt > 0 then\n        targetAlt = targetAlt - 0.01\n    end\n    else\n    targetAlt = 0.5\nend\n","filter":{"args":[{"value":"t"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"3"},{"code":"Nav:update()\n","filter":{"args":[],"signature":"onUpdate()","slotKey":"-4"},"key":"4"},{"code":"gearExtended = not gearExtended\nif gearExtended then\n    unit.deployLandingGears()\nelse\n    unit.retractLandingGears()\nend\n","filter":{"args":[{"value":"gear"}],"signature":"onActionStart(gear)","slotKey":"-4"},"key":"5"},{"code":"if unit.isAnyHeadlightSwitchedOn() == 1 then\n    unit.switchOffHeadlights()\nelse\n    unit.switchOnHeadlights()\nend\n","filter":{"args":[{"value":"light"}],"signature":"onActionStart(light)","slotKey":"-4"},"key":"6"},{"code":"pitchInput = pitchInput - 1","filter":{"args":[{"value":"forward"}],"signature":"onActionStart(forward)","slotKey":"-4"},"key":"7"},{"code":"pitchInput = 0","filter":{"args":[{"value":"forward"}],"signature":"onActionStop(forward)","slotKey":"-4"},"key":"8"},{"code":"pitchInput = pitchInput + 1","filter":{"args":[{"value":"backward"}],"signature":"onActionStart(backward)","slotKey":"-4"},"key":"9"},{"code":"pitchInput = 0","filter":{"args":[{"value":"backward"}],"signature":"onActionStop(backward)","slotKey":"-4"},"key":"10"},{"code":"rollInput = rollInput - 1","filter":{"args":[{"value":"left"}],"signature":"onActionStart(left)","slotKey":"-4"},"key":"11"},{"code":"rollInput = 0","filter":{"args":[{"value":"left"}],"signature":"onActionStop(left)","slotKey":"-4"},"key":"12"},{"code":"rollInput = rollInput + 1","filter":{"args":[{"value":"right"}],"signature":"onActionStart(right)","slotKey":"-4"},"key":"13"},{"code":"rollInput = 0","filter":{"args":[{"value":"right"}],"signature":"onActionStop(right)","slotKey":"-4"},"key":"14"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)","filter":{"args":[{"value":"straferight"}],"signature":"onActionStart(straferight)","slotKey":"-4"},"key":"15"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)","filter":{"args":[{"value":"straferight"}],"signature":"onActionStop(straferight)","slotKey":"-4"},"key":"16"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)","filter":{"args":[{"value":"strafeleft"}],"signature":"onActionStart(strafeleft)","slotKey":"-4"},"key":"17"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)","filter":{"args":[{"value":"strafeleft"}],"signature":"onActionStop(strafeleft)","slotKey":"-4"},"key":"18"},{"code":"Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)\n","filter":{"args":[{"value":"up"}],"signature":"onActionStart(up)","slotKey":"-4"},"key":"19"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)\n","filter":{"args":[{"value":"up"}],"signature":"onActionStop(up)","slotKey":"-4"},"key":"20"},{"code":"Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)\n","filter":{"args":[{"value":"down"}],"signature":"onActionStart(down)","slotKey":"-4"},"key":"21"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(0)\n","filter":{"args":[{"value":"down"}],"signature":"onActionStop(down)","slotKey":"-4"},"key":"22"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)","filter":{"args":[{"value":"groundaltitudeup"}],"signature":"onActionStart(groundaltitudeup)","slotKey":"-4"},"key":"23"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)","filter":{"args":[{"value":"groundaltitudeup"}],"signature":"onActionLoop(groundaltitudeup)","slotKey":"-4"},"key":"24"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)","filter":{"args":[{"value":"groundaltitudedown"}],"signature":"onActionStart(groundaltitudedown)","slotKey":"-4"},"key":"25"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)","filter":{"args":[{"value":"groundaltitudedown"}],"signature":"onActionLoop(groundaltitudedown)","slotKey":"-4"},"key":"26"},{"code":"yawInput = yawInput - 1","filter":{"args":[{"value":"yawright"}],"signature":"onActionStart(yawright)","slotKey":"-4"},"key":"27"},{"code":"yawInput = 0","filter":{"args":[{"value":"yawright"}],"signature":"onActionStop(yawright)","slotKey":"-4"},"key":"28"},{"code":"yawInput = yawInput + 1","filter":{"args":[{"value":"yawleft"}],"signature":"onActionStart(yawleft)","slotKey":"-4"},"key":"29"},{"code":"yawInput = 0","filter":{"args":[{"value":"yawleft"}],"signature":"onActionStop(yawleft)","slotKey":"-4"},"key":"30"},{"code":"if manualControl then\nbrakeInput = brakeInput + 1\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)\n    if (math.abs(targetSpeed) > constants.epsilon) then\n        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))\n    end\nend\nmanualBrake = true\nend","filter":{"args":[{"value":"brake"}],"signature":"onActionStart(brake)","slotKey":"-4"},"key":"31"},{"code":"brakeInput = 0\nmanualBrake = false","filter":{"args":[{"value":"brake"}],"signature":"onActionStop(brake)","slotKey":"-4"},"key":"32"},{"code":"local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)\n    if (math.abs(targetSpeed) > constants.epsilon) then\n        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))\n    end\nend\n","filter":{"args":[{"value":"brake"}],"signature":"onActionLoop(brake)","slotKey":"-4"},"key":"33"},{"code":"Nav:toggleBoosters()","filter":{"args":[{"value":"booster"}],"signature":"onActionStart(booster)","slotKey":"-4"},"key":"34"},{"code":"Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)","filter":{"args":[{"value":"stopengines"}],"signature":"onActionStart(stopengines)","slotKey":"-4"},"key":"35"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)","filter":{"args":[{"value":"speedup"}],"signature":"onActionStart(speedup)","slotKey":"-4"},"key":"36"},{"code":"Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)","filter":{"args":[{"value":"speedup"}],"signature":"onActionLoop(speedup)","slotKey":"-4"},"key":"37"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)","filter":{"args":[{"value":"speeddown"}],"signature":"onActionStart(speeddown)","slotKey":"-4"},"key":"38"},{"code":"Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)","filter":{"args":[{"value":"speeddown"}],"signature":"onActionLoop(speeddown)","slotKey":"-4"},"key":"39"},{"code":"if antigrav ~= nil then antigrav.toggle() end","filter":{"args":[{"value":"antigravity"}],"signature":"onActionStart(antigravity)","slotKey":"-4"},"key":"40"},{"code":"targetAlt = targetAlt + 0.5","filter":{"args":[{"value":"option1"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"41"},{"code":"targetAlt = targetAlt - 0.5","filter":{"args":[{"value":"option2"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"42"},{"code":"-- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu\n\nlocal pitchSpeedFactor = 10.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal yawSpeedFactor = 11 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal rollSpeedFactor = 11.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01\nlocal brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal autoRoll = true --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)\nlocal autoRollFactor = 20 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01\n\nlocal turnAssist = false --export: [Only in atmosphere]\nlocal turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal torqueFactor = 22 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\n-- validate params\npitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)\nyawSpeedFactor = math.max(yawSpeedFactor, 0.01)\nrollSpeedFactor = math.max(rollSpeedFactor, 0.01)\ntorqueFactor = math.max(torqueFactor, 0.01)\nbrakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)\nbrakeFlatFactor = math.max(brakeFlatFactor, 0.01)\nautoRollFactor = math.max(autoRollFactor, 0.01)\nturnAssistFactor = math.max(turnAssistFactor, 0.01)\n\n-- final inputs\nlocal finalPitchInput = 0\nlocal finalRollInput = 0\nlocal finalYawInput = 0\nlocal finalBrakeInput = 0\n\nif manualControl then\n    finalPitchInput = pitchInput + system.getControlDeviceForwardInput()\n    finalRollInput = rollInput + system.getControlDeviceYawInput()\n    finalYawInput = yawInput - system.getControlDeviceLeftRightInput()\n    finalBrakeInput = brakeInput\nend\n\nlocal constructAngularVelocity = vec3(construct.getWorldAngularVelocity())\n-- Axis\nlocal worldVertical = vec3(core.getWorldVertical()) -- along gravity\nlocal constructUp = vec3(construct.getWorldOrientationUp())\nconstructForward = vec3(construct.getWorldOrientationForward())\nconstructRight = vec3(construct.getWorldOrientationRight())\nconstructVelocity = vec3(construct.getWorldVelocity())\n\nif constructVelocity:len() < 0.1 then\n    velocityForwardDeg = 0\n    velocityRightDeg = 0\n    else\n    velocityForwardDeg = getRoll(constructVelocity, constructUp, constructRight)\n    velocityRightDeg = getRoll(constructVelocity, constructUp, -constructForward)\nend\n\nlocal constructVelocityDir = vec3(construct.getWorldVelocity()):normalize()\ncurrentRollDeg = getRoll(worldVertical, constructForward, constructRight)\nlocal currentRollDegSign = utils.sign(currentRollDeg)\n\ncurrentPitchDeg = getRoll(worldVertical, constructRight, -constructForward)\n\ncSelf = vec3(construct.getWorldPosition())\ndestTo = player.getWorldPosition()\nvDestTo = vec3(vec3(destTo) - cSelf):normalize_inplace()\nlenBSelf = (vec3(destTo) - vec3(cSelf)):len()\n\nvertDeg = getVertDeg(worldVertical,-constructUp)\ncurrentYawDeg = getRoll(vDestTo, constructUp, constructRight)\nif lenBSelf > targetMinDist then\n    targetMinDist = 2.5\n    if vertDeg < 70 or vertDeg > 110 then\n        currentRollDeg = -90\n        else\n        currentRollDeg = 0\n        currentPitchDeg = 0\n        currentYawDeg = 0\n        vdeg = getRoll(worldVertical, -constructUp, constructForward)\n        gTDeg = utils.clamp(getVertDeg(worldVertical,vDestTo) -90,-45,45)\n        yd=0\n        if vdeg > (-45 + gTDeg) and vdeg < (45 + gTDeg) then\n            currentPitchDeg = -getRoll(vDestTo, -constructRight, constructUp)\n            yd = currentPitchDeg\n            currentRollDeg = getRoll(worldVertical, constructForward, constructUp)\n        end\n        if vdeg > (45 + gTDeg) and vdeg < (135 + gTDeg) then\n            currentRollDeg = -getRoll(vDestTo, -constructForward, constructUp)\n            yd = currentRollDeg\n            currentPitchDeg = getRoll(worldVertical, -constructRight, constructUp)\n        end\n        if vdeg > (135 + gTDeg) or vdeg < (-135 + gTDeg) then\n            currentPitchDeg = getRoll(vDestTo, constructRight, constructUp)\n            yd = currentPitchDeg\n            currentRollDeg = -getRoll(worldVertical, -constructForward, constructUp)\n        end\n        if vdeg > (-135 + gTDeg) and vdeg < (-45 + gTDeg) then\n            currentRollDeg = getRoll(vDestTo, constructForward, constructUp)\n            yd = currentRollDeg\n            currentPitchDeg = -getRoll(worldVertical, constructRight, constructUp)\n        end\n        if math.abs(yd) < 7 then\n            currentYawDeg = 180\n        end\n    end\n    else\n    targetMinDist = 3.5\nend\nlocal currentRollDegAbs = math.abs(currentRollDeg)\nlocal currentPitchDegAbs = math.abs(currentPitchDeg)\n\nif vertDeg > 265 then\n    currentRollDeg = 0\n    currentPitchDeg = 0\n    currentYawDeg = 0\n    percX = 0\n    autoRollFactor = 20\n    if not manualBrake then\n        finalBrakeInput = 1\n    end\n    folldownRightDeg = getRoll(worldVertical, constructUp, constructRight)\n    if math.abs(folldownRightDeg) < 75 or math.abs(folldownRightDeg) > 115  then\n        if folldownRightDeg < 0 then\n            currentYawDeg = folldownRightDeg + 90\n            else\n            currentYawDeg = folldownRightDeg - 90\n        end\n        else\n        if folldownRightDeg < 0 then\n            currentRollDeg = -vertDeg\n            else\n            currentRollDeg = vertDeg\n        end\n    end\n    else\n    autoRollFactor = 6\n    percX = percX + math.sin(math.rad(currentPitchDegAbs*2))*0.25 \n    + math.sin(math.rad(currentRollDegAbs*2))*0.25\n    if lenBSelf < 3.7 then\n        if not manualBrake then\n            finalBrakeInput = 1\n        end\n        else\n        \n        if not manualBrake then\n            finalBrakeInput = 0\n        end\n        if math.abs(velocityForwardDeg) > 140 or addPitchDeg < -20 or math.abs(addRollDeg) > 20 then\n            if not manualBrake then\n                finalBrakeInput = 1\n            end\n        end\n        currentPitchDeg = currentPitchDeg + addPitchDeg\n        if math.abs(velocityForwardDeg) > 0.5 and math.abs(velocityForwardDeg) < 140 then\n            currentRollDeg = currentRollDeg + addRollDeg\n        end\n    end\nend\nautoRoll = true\n\n\nlocal currentYawDegAbs = math.abs(currentYawDeg)\ncurrentRollDegAbs = math.abs(currentRollDeg)\ncurrentPitchDegAbs = math.abs(currentPitchDeg)\n\n-- Rotation\nlocal targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight\n                                + finalRollInput * rollSpeedFactor * constructForward\n                                + finalYawInput * yawSpeedFactor * constructUp\n\n-- In atmosphere?\nif worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then\n    local autoRollRollThreshold = 0.1\n    if distance < 0.05 then\n        autoRollRollThreshold = 1.0\n        constructAngularVelocity = vec3()\n    end\n    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling\n    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then\n        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit\n        if (rollPID == nil) then\n            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n        end\n        rollPID:inject(targetRollDeg - currentRollDeg)\n        local autoRollInput = rollPID:get()\n\n        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward\n    end\n    \n    -- autoPitch\n    if autoRoll == true and currentPitchDegAbs > autoRollRollThreshold and finalPitchInput == 0 then\n        local targetPitchDeg = utils.clamp(0,currentPitchDegAbs-30, currentPitchDegAbs+30);  -- we go back to 0 within a certain limit\n        if (PitchPID == nil) then\n            PitchPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n        end\n        PitchPID:inject(targetPitchDeg - currentPitchDeg)\n        local autoPitchInput = PitchPID:get()\n\n        targetAngularVelocity = targetAngularVelocity + autoPitchInput * constructRight\n    end\n    \n    -- autoYaw\n    if autoRoll == true and currentYawDegAbs > autoRollRollThreshold and finalYawInput == 0 then\n        local targetYawDeg = utils.clamp(0,currentYawDegAbs-30, currentYawDegAbs+30);  -- we go back to 0 within a certain limit\n        if (YawPID == nil) then\n            YawPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n        end\n        YawPID:inject(targetYawDeg - currentYawDeg)\n        local autoYawInput = YawPID:get()\n\n        targetAngularVelocity = targetAngularVelocity + autoYawInput * constructUp\n    end\n    \n    local turnAssistRollThreshold = 20.0\n    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing\n    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then\n        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range\n        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range\n\n        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)\n        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180\n        local rollVerticalRatio = 0\n        if rescaleRollDegAbs < 90 then\n            rollVerticalRatio = rescaleRollDegAbs / 90\n        elseif rescaleRollDegAbs < 180 then\n            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90\n        end\n\n        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio\n\n        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)\n        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio\n\n        targetAngularVelocity = targetAngularVelocity\n                            + turnAssistPitchInput * constructRight\n                            + turnAssistYawInput * constructUp\n    end\nend\n\n-- Engine commands\nlocal keepCollinearity = 1 -- for easier reading\nlocal dontKeepCollinearity = 0 -- for easier reading\nlocal tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities\n\n-- Rotation\nlocal angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)\nlocal airAcceleration = vec3(construct.getWorldAirFrictionAngularAcceleration())\nangularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction\nNav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)\n\n-- Brakes\nlocal brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)\nNav:setEngineForceCommand('brake', brakeAcceleration)\n\n-- AutoNavigation regroups all the axis command by 'TargetSpeed'\nlocal autoNavigationEngineTags = ''\nlocal autoNavigationAcceleration = vec3()\nlocal autoNavigationUseBrake = false\n\n-- Longitudinal Translation\nlocal longitudinalEngineTags = 'thrust analog longitudinal'\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byThrottle) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)\n    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)\nelseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration\n    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop\n        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5)\n    then\n        autoNavigationUseBrake = true\n    end\n\nend\n\n-- Lateral Translation\nlocal lateralStrafeEngineTags = 'thrust analog lateral'\nlocal lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)\nif (lateralCommandType == axisCommandType.byThrottle) then\n    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)\n    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)\nelseif  (lateralCommandType == axisCommandType.byTargetSpeed) then\n    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration\nend\n\n-- Vertical Translation\nlocal verticalStrafeEngineTags = 'thrust analog vertical'\nlocal verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)\nif (verticalCommandType == axisCommandType.byThrottle) then\n    verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)\n    verticalStrafeAcceleration = verticalStrafeAcceleration * percX\n    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, 0, '', '', '', tolerancePercentToSkipOtherPriorities)\n    vertAcceleration = verticalStrafeAcceleration\n    --unit.setEngineCommand(\"vert\",vertAcceleration,{0,0,0},0,0,'', '', '',1)\nNav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nelseif  (verticalCommandType == axisCommandType.byTargetSpeed) then\n    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration\nend\n\n-- Auto Navigation (Cruise Control)\nif (autoNavigationAcceleration:len() > constants.epsilon) then\n    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward\n    then\n        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'\n    end\n    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\nend\n\n-- Rockets\nNav:setBoosterCommand('rocket_engine')\n\n","filter":{"args":[],"signature":"onFlush()","slotKey":"-4"},"key":"43"},{"code":"if manualControl then\n    manualControl = false\nelse\n    manualControl = true\nend","filter":{"args":[{"value":"option3"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"44"}],"methods":[],"events":[]}
